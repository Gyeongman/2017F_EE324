20150073 김경만
web_server: 우선 queue를 전역변수로 설정한 뒤 메모리를 할당해주었으며 요청이 들어왔을 때 그 요청의 정보가 담긴 node를 메모리에 할당한 뒤 queue에 연결리스트처럼 뒤에 붙게 구현했습니다. 처음에 main thread는 10개의 thread pool을 만든 뒤 pool과 select를 이용하여 I/O multiplexing이 가능하게 했습니다. 또한 queue가 비어있다면 요청을 받아야하며 queue가 비어있지 않다면 full이라는 상태변수를 기다리도록 했습니다. 이 full이라는 상태변수는 thread pool 안의 thread가 request를 다 처리한 뒤 빈 queue를 다시 채워달라는 의미입니다. thread pool에 있는 thread들은 우선 cond_cnt를 줄여가며 wake라는 상태변수에 의해 모두들 기다리고 있으며 이 cond_cnt를 0으로 만드는 마지막 thread는 다시 cond_cnt를 10으로 만들고 모든 pool의 thread들을 wake라는 상태변수를 통해 깨웁니다. 이렇게 되면 request들을 thread마다 하나씩 처리한 뒤 sleep한 상태이기 때문에 공평하게 배분할 수 있습니다. 또한 이렇게 wake에 의해 깨어나면 queue가 비지 않을때까지 cond라는 상태변수에 의해 기다리게 되며 이 cond라는 상태변수는 main thread에서 queue에 request를 넣을 때 보내줍니다. 그렇게 요청을 받게 되는 thread는 HTTP request를 읽고 HTTP response를 보내며 index.html도 전송합니다. 또한 log함수를 작성한 뒤 '0'이 20개 있는 문자열을 전송하여 index.html이 끝났음을 알려줍니다. 
client: main함수에서는 인자로 받은 수만큼 thread를 만들었으며 join을 이용하여 모든 thread가 끝날때까지 기다렸다가 종료했습니다. 각 thread에서는 만들어야하는 요청 수만큼 for문으로 반복하며 소켓을 만들고 connect한 뒤 HTTP request를 보내고 HTTP response를 받은 뒤 index.html을 끝까지 읽도록 했습니다. 여기서 index.html이 끝나면 '0'이 20개 있는 문자열을 받도록 설정했기 때문에 이러한 문자열을 받으면 소켓을 닫습니다.